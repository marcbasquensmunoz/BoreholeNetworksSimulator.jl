var documenterSearchIndex = {"docs":
[{"location":"api/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"api/#General","page":"Public API","title":"General","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"initialize","category":"page"},{"location":"api/#BoreholeNetworksSimulator.initialize","page":"Public API","title":"BoreholeNetworksSimulator.initialize","text":"initialize(options::SimulationOptions)\n\nPrecompute the objects of each TimeSuperpositionMethod that can be computed ahead of time and return the SimulationContainers of the required size.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Public API","title":"Public API","text":"simulate!","category":"page"},{"location":"api/#BoreholeNetworksSimulator.simulate!","page":"Public API","title":"BoreholeNetworksSimulator.simulate!","text":"simulate!(;options::SimulationOptions, operator, containers::SimulationContainers)\n\nRun the simulation defined by options.  At the end of simulation, containers.X will contain the results. containers should be the output of initialize.\n\noperator should be a function that returns a BoreholeOperation and with signature operator(i, Tin, Tout, Tb, q, configurations):\n\ni::Int is the time step\nTin is a vector containing the inlet temperature of each borehole\nTout is a vector containing the outlet temperature of each borehole\nTb is a vector containing the borehole wall temperature of each borehole\nq is a vector containing the heat exchanged by each borehole\nconfigurations: is the list of possible hydraulic configurations of the borefield.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Public API","title":"Public API","text":"BoreholeNetwork","category":"page"},{"location":"api/#BoreholeNetworksSimulator.BoreholeNetwork","page":"Public API","title":"BoreholeNetworksSimulator.BoreholeNetwork","text":"BoreholeNetwork(branches::Vector)\n\nRepresentation of the hydraulic connections of the boreholes in the network. Each element in branches should be a vector representing a branch of boreholes connected in series, specified by their identifiers. The first borehole of each branch is assumed to be connected in parallel. \n\n\n\n\n\n","category":"type"},{"location":"api/","page":"Public API","title":"Public API","text":"BoreholeOperation","category":"page"},{"location":"api/#BoreholeNetworksSimulator.BoreholeOperation","page":"Public API","title":"BoreholeNetworksSimulator.BoreholeOperation","text":"BoreholeOperation{T <: Number}(network::BoreholeNetwork, mass_flows:: Vector{T})\n\nRepresents a operation state of the network, with network representing the hydraulic configuration and mass_flows a Vector containing the mass flow rate of each branch.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation-Options","page":"Public API","title":"Simulation Options","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"SimulationOptions","category":"page"},{"location":"api/#BoreholeNetworksSimulator.SimulationOptions","page":"Public API","title":"BoreholeNetworksSimulator.SimulationOptions","text":"struct SimulationOptions{\n                TSM <: TimeSuperpositionMethod,\n                C <: Constraint,\n                B <: Borefield, \n                M <: Medium, \n                BC <: BoundaryCondition\n            }(\n    method::TSM\n    constraint::C\n    borefield::B\n    medium::M\n    boundary_condition::BoundaryCondition = DirichletBoundaryCondition()\n    fluid::Fluid = Fluid(cpf=4182., name=\"INCOMP::MEA-20%\")\n    configurations::Vector{BoreholeNetwork}\n    Δt\n    Nt::Int\n)\n\nSpecifies all the options for the simulation.\n\nmethod: time superposition method used to compute the response. Available options: ConvolutionMethod, NonHistoryMethod.\nconstraint: constraint that the system must satisfy. Can be variable with time. Available options: HeatLoadConstraint, InletTempConstraint.\nborefield: describes the geometrical properties and the boreholes of the borefield on which the simulation will be performed. Available options: EqualBoreholesBorefield.\nmedium: properties of the ground where the borefield is places. Available options: GroundMedium, FlowInPorousMedium.\nboundary_condition: boundary condition of the domain where the simulation is performed. Available options: NoBoundary, DirichletBoundaryCondition.\nfluid: properties of the fluid flowing through the hydraulic system.\nconfigurations: possible hydraulic topologies possible in the system, including reverse flow.\nΔt: time step used in the simulation.\nNt: total amount of time steps of the simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Medium","page":"Public API","title":"Medium","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Medium","category":"page"},{"location":"api/#BoreholeNetworksSimulator.Medium","page":"Public API","title":"BoreholeNetworksSimulator.Medium","text":"abstract type Medium\n\nInterface for mediums.\n\nRequired functions:\n\nget_λ(::Medium): Return the thermal conductivity of the medium.\nget_α(::Medium): Return the thermal diffusivity of the medium.\nget_T0(::Medium): Return the initial temperature of the medium.\ncompute_response!(g, ::Medium, borefield::Borefield, boundary_condition::BoundaryCondition, t):    Compute inplace in g the thermal responses between boreholes in borefield,    imposing the boundary condition boundary_condition, for all times in t.\n\n\n\n\n\n","category":"type"},{"location":"api/#Options","page":"Public API","title":"Options","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"GroundMedium","category":"page"},{"location":"api/#BoreholeNetworksSimulator.GroundMedium","page":"Public API","title":"BoreholeNetworksSimulator.GroundMedium","text":"GroundMedium{T <: Real} <: Medium @deftype T\n\nModel pure conduction in the ground.\n\nArguments\n\nλ = 3.: ground conductivity\nα = 1e-6: ground thermal diffusivity\nC = λ/α: ground medium capacity\nT0 = 0.: initial ground temperature\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"Public API","title":"Public API","text":"FlowInPorousMedium","category":"page"},{"location":"api/#BoreholeNetworksSimulator.FlowInPorousMedium","page":"Public API","title":"BoreholeNetworksSimulator.FlowInPorousMedium","text":"FlowInPorousMedium{T <: Real} <: Medium @deftype T\n\nModel a porous ground with a water flow.\n\nArguments\n\nλw = 0.6: water thermal conductivity\nλs = 2.: ground thermal conductivity\nCw = 4.18*1e6:water thermal capacity\nCs = 1.7*1e6: ground thermal capacity\nθ = 0.: angle of Darcy velocity\nΦ = 0.2: porosity\nλ = λs * (1-Φ) + λw*Φ: porous medium conductivity\nC = Cs * (1-Φ) + Cw*Φ: porous medium capacity\nα = λ/C: porous medium thermal diffusivity\nux_in_meterperday = 1e-2: groundwater speed along the flow coordinate\nux = ux_in_meterperday/(3600*24): groundwater speed in m/s\nvt = ux * Cw/C: porous medium darcy velocity\nT0 = 0.: initial ground temperature\n\n\n\n\n\n","category":"type"},{"location":"api/#Borefield","page":"Public API","title":"Borefield","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Borefield","category":"page"},{"location":"api/#BoreholeNetworksSimulator.Borefield","page":"Public API","title":"BoreholeNetworksSimulator.Borefield","text":"abstract type Borefield\n\nInterface for borefields.\n\nRequired functions\n\nn_boreholes(::Borefield): Return the amount of boreholes present in the borefield.\nget_H(::Borefield, i): Return the length of borehole i.\nget_rb(::Borefield, i): Return the radius of borehole i.\nsegment_coordinates(::Borefield): Return a vector with the coordinates of each segment.  \ninternal_model_coeffs!(M, ::Borefield, medium, operation, fluid): Compute inplace in M   the coefficients corresponding to the internal model equations, given the medium, fluid and   operation in use in the system.   Note that M is only a slice of Nb (number of boreholes) rows, provided as a view.\ninternal_model_b!(b, ::Borefield): Compute inplace in b   the independent terms corresponding to the internal model equations.   Note that b is only a vector of length Nb (number of boreholes) rows, provided as a view.\n\n\n\n\n\n","category":"type"},{"location":"api/#Options-2","page":"Public API","title":"Options","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"EqualBoreholesBorefield","category":"page"},{"location":"api/#BoreholeNetworksSimulator.EqualBoreholesBorefield","page":"Public API","title":"BoreholeNetworksSimulator.EqualBoreholesBorefield","text":"EqualBoreholesBorefield{T <: Borehole, R <: Medium, S <: Real} <: Borefield\nEqualBoreholesBorefield(borehole_prototype::T, positions::Vector{Point2{S}}), medium::R)\n\nModel a borefield with boreholes all identical to the prototype borehole_prototype, placed at positions. Note that the length of positions determines the amount of boreholes in the field. medium contains the properties of the ground.\n\n\n\n\n\n","category":"type"},{"location":"api/#Borehole","page":"Public API","title":"Borehole","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Borehole","category":"page"},{"location":"api/#BoreholeNetworksSimulator.Borehole","page":"Public API","title":"BoreholeNetworksSimulator.Borehole","text":"abstract type Borehole\n\nInterface for boreholes.\n\nRequired functions:\n\nget_H(::Borehole): Return the length of the borehole.\nget_D(::Borehole): Return the burial depth of the borehole.\nget_rb(::Borehole): Return the radius of the borehole.\nuniform_Tb_coeffs(::Borehole, λ, mass_flow, Tref, fluid): Return the internal model coefficients   for the resistance network between the pipes and the wall.\n\n\n\n\n\n","category":"type"},{"location":"api/#Options-3","page":"Public API","title":"Options","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"SingleUPipeBorehole","category":"page"},{"location":"api/#BoreholeNetworksSimulator.SingleUPipeBorehole","page":"Public API","title":"BoreholeNetworksSimulator.SingleUPipeBorehole","text":"SingleUPipeBorehole{T <: Real} <: Borehole @deftype T\nSingleUPipeBorehole(H, D)\n\nModel a borehole with a single U-pipe with burial depth D and length H.\n\nArguments\n\nλg = 2.5: grout conductivity\nCg = 2000. * 1550.: grout capacity\nαg = λg/Cg: grout thermal diffusivity\nrp = 0.02: pipe radius\nλp = 0.42: pipe material conductivity\ndpw = 0.0023: pipe thickness\nrpo = rp + dpw: equivalent pipe radius\nhp = 725.: heat transfer coefficient fluid to pipe\npipe_position::NTuple{2, Tuple{T, T}} = [(0.03, 0.0), (-0.03, 0.0)]: positions of the downward and upward branches of the pipe. (0, 0) represents the center of the borehole.\nrb = 0.115/2: borehole radius\n\n\n\n\n\n","category":"type"},{"location":"api/#Constraint","page":"Public API","title":"Constraint","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Constraint","category":"page"},{"location":"api/#BoreholeNetworksSimulator.Constraint","page":"Public API","title":"BoreholeNetworksSimulator.Constraint","text":"abstract type Constraint\n\nInterface for constraints.\n\nRequired functions:\n\nconstraints_coeffs!(M, ::Constraint, operation::BoreholeOperation): Compute inplace in M   the coefficients corresponding to the constraints equations, given the current operation.network.    Note that M is only a slice of Nbr (number of branches) rows, provided as a view.\nconstraints_b!(b, ::Constraint, ::BoreholeOperation, step): Compute inplace in b   the independent term corresponding to the constraints equations, given the current operation.network,   at the time step step.    Note that b is only a vector of length Nbr (number of branches), provided as a view.\n\n\n\n\n\n","category":"type"},{"location":"api/#Options-4","page":"Public API","title":"Options","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"HeatLoadConstraint","category":"page"},{"location":"api/#BoreholeNetworksSimulator.HeatLoadConstraint","page":"Public API","title":"BoreholeNetworksSimulator.HeatLoadConstraint","text":"HeatLoadConstraint(Q_tot::Matrix{T}){T <: Number} <: Constraint\n\nConstrain the heat extracted per branch.\n\nThe heat constraint Q_tot must be a Matrix, whose column i are the loads per branch at the  time step i. The amount of rows of Q_tot must equal to the amount of branches specified  in BoreholeNetwork.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"Public API","title":"Public API","text":"InletTempConstraint","category":"page"},{"location":"api/#BoreholeNetworksSimulator.InletTempConstraint","page":"Public API","title":"BoreholeNetworksSimulator.InletTempConstraint","text":"InletTempConstraint(T_in::Matrix{T}){T <: Number} <: Constraint\n\nConstrain the inlet temperature of the first borehole in each branch.\n\nThe inlet temperature T_in must be a Matrix, whose column i are the inlet temperatures per branch at the  time step i. The amount of rows of T_in must equal to the amount of branches specified  in BoreholeNetwork.\n\n\n\n\n\n","category":"type"},{"location":"api/#Time-Superposition-Method","page":"Public API","title":"Time Superposition Method","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"TimeSuperpositionMethod","category":"page"},{"location":"api/#BoreholeNetworksSimulator.TimeSuperpositionMethod","page":"Public API","title":"BoreholeNetworksSimulator.TimeSuperpositionMethod","text":"abstract type TimeSuperpositionMethod\n\nInterface for time superposition methods.\n\nRequired functions:\n\nmethod_coeffs!(M, ::TimeSuperpositionMethod, borefield, medium, boundary_condition): Compute inplace in M   the coefficients corresponding to the heat transfer equations, given the medium,    and boundary_condition in use in the system.   Note that M is only a slice of Nbr (number of branches) rows, provided as a view.\nmethod_b!(b, ::TimeSuperpositionMethod, borefield, medium, step): Compute inplace in b   the independent terms corresponding to the heat transfer equations, given the medium,    at the given time step step.   Note that b is only a vector of length Nbr (number of branches) rows, provided as a view.\nprecompute_auxiliaries!(method::TimeSuperpositionMethod; options): Compute inplace in method    the auxiliary quantities used in the simulation that can be performed ahead of time.\nupdate_auxiliaries!(::TimeSuperpositionMethod, X, borefield, step): Update inplace in method   the auxiliaries after each time step step.\n\n\n\n\n\n","category":"type"},{"location":"api/#Options-5","page":"Public API","title":"Options","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"ConvolutionMethod","category":"page"},{"location":"api/#BoreholeNetworksSimulator.ConvolutionMethod","page":"Public API","title":"BoreholeNetworksSimulator.ConvolutionMethod","text":"ConvolutionMethod{T} <: TimeSuperpositionMethod \nConvolutionMethod()\n\nUse the naïve convolution to compute the thermal response between boreholes.  It should be initialized without arguments, but it contains the variables:\n\ng stores the unit response between each pair of boreholes evaluated at each time of the simulation. \n\nIt should be precomputed with initialize.\n\nq stores the heat extraction in each borehole at each time step. It is filled as the simulation runs. \n\n\n\n\n\n","category":"type"},{"location":"api/","page":"Public API","title":"Public API","text":"NonHistoryMethod","category":"page"},{"location":"api/#BoreholeNetworksSimulator.NonHistoryMethod","page":"Public API","title":"BoreholeNetworksSimulator.NonHistoryMethod","text":"NonHistoryMethod{T} <: TimeSuperpositionMethod \nNonHistoryMethod()\n\nUse the non-history method to compute the thermal response between boreholes.  See A non-history dependent temporal superposition algorithm for the finite line source solution. It should be initialized without arguments, but it contains the variables:\n\nF::Matrix{T}: each column contains the F function (encoding the load history) for each borehole. It is initially 0.\nζ::Vector{T}: discretization nodes of the integration interval. Shared for all boreholes. Precomputed in initialize.\nw::Matrix{T}: weights of the ζ integration for each pair of boreholes. Precomputed in initialize.\nexpΔt::Vector{T}: exp(-ζ^2*Δt). Precomputed in initialize.\n\n\n\n\n\n","category":"type"},{"location":"api/#Boundary-Condition","page":"Public API","title":"Boundary Condition","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"BoundaryCondition","category":"page"},{"location":"api/#BoreholeNetworksSimulator.BoundaryCondition","page":"Public API","title":"BoreholeNetworksSimulator.BoundaryCondition","text":"abstract type BoundaryCondition\n\nInterface for boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"api/#Options-6","page":"Public API","title":"Options","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"NoBoundary","category":"page"},{"location":"api/#BoreholeNetworksSimulator.NoBoundary","page":"Public API","title":"BoreholeNetworksSimulator.NoBoundary","text":"NoBoundary <: BoundaryCondition\n\nOption to solve the problem in an infinite domain \n\n\n\n\n\n","category":"type"},{"location":"api/","page":"Public API","title":"Public API","text":"DirichletBoundaryCondition","category":"page"},{"location":"api/#BoreholeNetworksSimulator.DirichletBoundaryCondition","page":"Public API","title":"BoreholeNetworksSimulator.DirichletBoundaryCondition","text":"DirichletBoundaryCondition <: BoundaryCondition\n\nOption to enforce that the surface plane z=0 remains at temperature T=0\n\n\n\n\n\n","category":"type"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"EditURL = \"nonhistory.jl\"","category":"page"},{"location":"nonhistory/#Non-history-method","page":"Non-history method","title":"Non-history method","text":"","category":"section"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"The non-history method is a time superposition method introduced in [1] whose computational complexity in the number of time steps N_t is mathcalOleft( N_t right). Recall that the standard way to do time superposition is via the convolution of the load with the response, which implemented via the Fast Fourier Transform, yields a computational complexity of mathcalOleft( N_t logN_t right). This means that using the non-history method in simulations allows for finer time steps.","category":"page"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"To show this, let us run a simulation with hourly time steps, with a duration of 20 years (so 175200 time steps), with both the convolution and the non-history time superposition methods. Let us define an example, very similar to","category":"page"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"using BoreholeNetworksSimulator\n\nΔt = 8760*3600/12.     # Hourly time step\nNt = 2\n\nmedium = GroundMedium(α=1e-6, λ=3., T0=10.)\npositions = [(0., 0.), (0., 5.)]\nborehole = SingleUPipeBorehole(H=100., D=10.)\nborefield = EqualBoreholesBorefield(borehole_prototype=borehole, positions=positions)\nconfigurations = [BoreholeNetwork([[1], [2]])]\nconstraint = constant_HeatLoadConstraint(5 .* ones(BoreholeNetworksSimulator.n_boreholes(borefield)), Nt)\n\nfunction operator(i, Tin, Tout, Tb, q, configurations)\n    BoreholeOperation(configurations[1], 2 .* ones(2))\nend","category":"page"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"Now, we define two different options using different method parameters, one with ConvolutionMethod corresponding to the convolution, and the other with NonHistoryMethod, corresponding with the non-history method.","category":"page"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"options_convolution = SimulationOptions(\n    method = ConvolutionMethod(),\n    constraint = constraint,\n    borefield = borefield,\n    medium = medium,\n    Δt = Δt,\n    Nt = Nt,\n    configurations = configurations\n)\n\noptions_nonhistory = SimulationOptions(\n    method = NonHistoryMethod(),\n    constraint = constraint,\n    borefield = borefield,\n    medium = medium,\n    Δt = Δt,\n    Nt = Nt,\n    configurations = configurations\n)","category":"page"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"Let us run the convolution","category":"page"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"containers_convolution = @time initialize(options_convolution)\n@time simulate!(operator=operator, options=options_convolution, containers=containers_convolution)","category":"page"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"And now let us run the non-history","category":"page"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"containers_nonhistory = @time initialize(options_nonhistory)\n@time simulate!(operator=operator, options=options_nonhistory, containers=containers_nonhistory)","category":"page"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"There is a massive speed up! We can also check that the two solutions are identical","category":"page"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"sum(abs.(containers_convolution.X - containers_nonhistory.X))","category":"page"},{"location":"nonhistory/#References","page":"Non-history method","title":"References","text":"","category":"section"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"[1] Lazzarotto, Alberto; Basquens, Marc; Cimmino, Massimo; Non-history dependent temporal superposition algorithm for the pint source solution, Research Conference Proceedings of the IGSHPA (2024).","category":"page"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"","category":"page"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"This page was generated using Literate.jl.","category":"page"},{"location":"python/#Running-BoreholeNetworksSimulator-from-Python","page":"Running BoreholeNetworksSimulator from Python","title":"Running BoreholeNetworksSimulator from Python","text":"","category":"section"},{"location":"python/","page":"Running BoreholeNetworksSimulator from Python","title":"Running BoreholeNetworksSimulator from Python","text":"It is also possible to run BoreholeNetworksSimulator from Python by using its Julia interoperability (achieved with the package PythonCall.jl and the module juliacall) while keeping roughly the same syntax. For a more detailed explanation of how this works, please visit the PythonCall.jl documentation. This requires to have installed in your python environment the modules juliacall and numpy.","category":"page"},{"location":"python/","page":"Running BoreholeNetworksSimulator from Python","title":"Running BoreholeNetworksSimulator from Python","text":"BoreholeNetworksSimulator contains a python script python/adapter.py that runs the necessary bridging code. You should start your python program by importing this module. Assuming that the package directory is added to the sys.path, this should work:","category":"page"},{"location":"python/","page":"Running BoreholeNetworksSimulator from Python","title":"Running BoreholeNetworksSimulator from Python","text":"import python.adapter","category":"page"},{"location":"python/","page":"Running BoreholeNetworksSimulator from Python","title":"Running BoreholeNetworksSimulator from Python","text":"The script takes care of activating the Julia package BoreholeNetworksSimulator to make it accessible, as well as defining conversions from python objects to their Julia counterpart.  Next, we need to import juliacall to be able to reference objects and funcions from BoreholeNetworksSimulator. It is useful to give it an alias for conciseness.","category":"page"},{"location":"python/","page":"Running BoreholeNetworksSimulator from Python","title":"Running BoreholeNetworksSimulator from Python","text":"from juliacall import Main as jl","category":"page"},{"location":"python/","page":"Running BoreholeNetworksSimulator from Python","title":"Running BoreholeNetworksSimulator from Python","text":"Now, the python variable jl represents the Main module in Julia, and it has as methods all the Julia functions available in it. Since we activated BoreholeNetworksSimulator, this also includes its objects and functions.","category":"page"},{"location":"python/","page":"Running BoreholeNetworksSimulator from Python","title":"Running BoreholeNetworksSimulator from Python","text":"We will repeat the example in the first tutorial to show how to run the simulation.","category":"page"},{"location":"python/","page":"Running BoreholeNetworksSimulator from Python","title":"Running BoreholeNetworksSimulator from Python","text":"Δt = 8760*3600/12.\nNt = 10*12\n\nα = 1e-6\nλ = 3.\nT0 = 10.\nmedium = jl.GroundMedium(α=α, λ=λ, T0=T0)\n\nD = 10.\nH = 100.\n\nborehole = jl.SingleUPipeBorehole(H=H, D=D)\n\nσ = 5.\npositions = jl.Array[jl.Tuple[jl.Float64, jl.Float64]]([(0., 0.), (0., σ)])\nborefield = jl.EqualBoreholesBorefield(borehole_prototype=borehole, positions=positions)\n\nconfigurations = [jl.BoreholeNetwork([[1], [2]])]\n\nq1 = 5.\nq2 = 5.\nloads = jl.Array[jl.Float64]([q1, q2])\nconstraint = jl.constant_HeatLoadConstraint(loads, Nt)\n\noptions = jl.SimulationOptions(\n    method = jl.ConvolutionMethod(),\n    constraint = constraint,\n    borefield = borefield,\n    medium = medium,\n    Δt = Δt,\n    Nt = Nt,\n    configurations = configurations\n)","category":"page"},{"location":"python/","page":"Running BoreholeNetworksSimulator from Python","title":"Running BoreholeNetworksSimulator from Python","text":"The code itself is not very different from its Julia version, but there are two remarks worth making. First, we need to call any object defined in Julia by typing jl. in front. This creates a python object with the same fields that juliacall knows how to convert back into a Julia object. Second, note that we have defined the arrays by explicitly declaring their generic type. If we don't do this, they will be converted into Vector{Any} in the Julia code, which is not desirable.","category":"page"},{"location":"python/","page":"Running BoreholeNetworksSimulator from Python","title":"Running BoreholeNetworksSimulator from Python","text":"Another difference is the definition of our operator object. Since we are writing python, it should now be a python function, however, since the Julia code is expecting an object of type BoreholeOperation, its return type must be jl.BoreholeOperation, that PythonCall.jl knows how to convert. ","category":"page"},{"location":"python/","page":"Running BoreholeNetworksSimulator from Python","title":"Running BoreholeNetworksSimulator from Python","text":"def operator(i, Tin, Tout, Tb, q, configurations):\n    jl.BoreholeOperation(configurations[0], jl.Array[jl.Float64]([2., 2.]))","category":"page"},{"location":"python/","page":"Running BoreholeNetworksSimulator from Python","title":"Running BoreholeNetworksSimulator from Python","text":"Finally we can run the simulation","category":"page"},{"location":"python/","page":"Running BoreholeNetworksSimulator from Python","title":"Running BoreholeNetworksSimulator from Python","text":"containers = jl.initialize(options)\njl.simulate_b(operator=operator, options=options, containers=containers)","category":"page"},{"location":"python/","page":"Running BoreholeNetworksSimulator from Python","title":"Running BoreholeNetworksSimulator from Python","text":"Note that the bang in simulate! is replaced by a _b in the juliacall version of the function. ","category":"page"},{"location":"python/","page":"Running BoreholeNetworksSimulator from Python","title":"Running BoreholeNetworksSimulator from Python","text":"containers.X","category":"page"},{"location":"python/","page":"Running BoreholeNetworksSimulator from Python","title":"Running BoreholeNetworksSimulator from Python","text":"Now, one can compare this result with its Julia version. If everything went right, they should agree!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"BoreholeNetworksSimulator.jl is a pure Julia, performant, and modular framework for simulations of fields of boreholes. Features:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Computes fluid temperatures, borehole wall temperatures and heat extracted. \nHighly modular: different boreholes, hydraulic configurations, ground properties, load demand or temperature  constraints, ground boundary conditions can be seamlessly used with minimal effort. \nAllows for design of operation strategies via an operator callback at each time step.\nImplements the \"non-history\" time superposition method, reducing the computational complexity in the number of time steps to linear. This allows for simulations with fine time steps.","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"EditURL = \"tutorial.jl\"","category":"page"},{"location":"tutorial/#Basic-tutorial","page":"Basic tutorial","title":"Basic tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"In this tutorial we will learn how to simulate the expected temperature and heat extraction in a borehole field.","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"First, we need to specify the parameters and constraints of our system, as well as some options for the simulation. This is done through a SimulationOptions object. Its variables are modular components with which we can describe many scenarios by leveraging Julia's multiple dispatch. Let us see the components one by one with an example.","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"We start by specifying the simulation time step and the simulation duration. For our example, we will take monthly time steps during 10 years:","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"using BoreholeNetworksSimulator\n\nΔt = 8760*3600/12.\nNt = 10*12","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"Suppose the ground we are interested in simulating is made of solid rock. This means the heat transfer will occur by pure conduction. Assume that the thermal diffusivity of the rock is α = 10^-6 fracm^2s and its thermal conductivity is λ = 3 fracWm  K. The undisturbed temperature of the ground is T_0=10  ^circC. We model the ground with a subtype of Medium, in our case, as per our assumptions, we are particularly interested in GroundMedium:","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"α = 1e-6\nλ = 3.\nT0 = 10.\nmedium = GroundMedium(α=α, λ=λ, T0=T0)\n\n\nD = 10.\nH = 100.\nborehole = SingleUPipeBorehole(H=H, D=D)","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"Next, we need to know how and where the boreholes in our system are. Suppose we are interested in simulating the evolution of two identical vertical boreholes of length H=100m and buried at depth D=10m, separated by a distance of σ=5m. The boreholes are of the U-type. We need to enconde this information in a subtype of Borefield. Since the boreholes in our example have the same properties, we can use EqualBoreholesBorefield, which instantiates several identical boreholes from a prototype. The prototype is specified by a subtype of Borehole. In our case, we can use SingleUPipeBorehole to model a borehole with a single U-pipe.","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"D = 10.\nH = 100.\n\nborehole = SingleUPipeBorehole(H=H, D=D)","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"There are more parameters that are also relevant, such as borehole radius, grout properties, pipe resistance, etc., but for the moment we will use their default values.","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"Next, we need to specify where the borehole are located.","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"σ = 5.\npositions = [(0., 0.), (0., σ)]\nborefield = EqualBoreholesBorefield(borehole_prototype=borehole, positions=positions)","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"Note that we didn't specify yet how the boreholes are connected. This is because the simulation allows for dynamical changes in the network hydraulic configuration. Using different configurations, we can simulate the reverse flow, or even simulate valves opening and closing. The reason behind this design is to allow for decision making on the operation of the borefield during the simulation, based on the inputs that we are interested in.","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"For now, let us state the possible hydraulic configurations that we will allows our borefield to be in. This is done with an vector of BoreholeNetwork. Borefields usually have several branches of boreholes. Each borehole in a branch is connected in series, while branches may o may not be connected in parallel between themselves. To create a BoreholeNetwork, we need to provide all of its branches in a vector. Each branch is, in turn, a vector containing the identifiers, in order, of the boreholes present in that branch. Each identifier i::Int refers to the borehole located at position positions[i].","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"In our example, we want to simulate two independent boreholes, so each of them must be in a separate branch. Also, for the moment, we are only interested in this configuration, so we define:","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"configurations = [BoreholeNetwork([[1], [2]])]","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"Even with all these specifications, the evolution of the system is still not fully determined. The missing conditions are referred to as constraints, and are modeled by subtypes of Constraint. For instance, if we would like the two boreholes to be connected in parallel, we would still need to impose that their inlet temperatures be equal. In our example, since we want out boreholes to be independent, we will impose the total amount of heat that we want to extract from each borehole. We will impose a constant load, equal for both boreholes. This is specified by","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"q1 = 5.\nq2 = 5.\nconstraint = constant_HeatLoadConstraint([q1, q2], Nt)","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"We can finally create the object with all the options:","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"options = SimulationOptions(\n    method = ConvolutionMethod(),\n    constraint = constraint,\n    borefield = borefield,\n    medium = medium,\n    Δt = Δt,\n    Nt = Nt,\n    configurations = configurations\n)","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"As we have mentioned, the simulation is designed to allow for a controllable opeartion during its duration. We do this by defining a function that takes as an input the current state of the borefield and outputs a BoreholeOperation object. This object has two variables: the first specifies which configuration will be used for the next time step. In our case, we only want a single configuration. The second specifies the mass flow rate through each branch of the selected configuration, provided as a vector. In our example, we will keep this constant through the simulation:","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"function operator(i, Tin, Tout, Tb, q, configurations)\n    BoreholeOperation(configurations[1], 2 .* ones(2))\nend","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"Before simulating, we first need to call initialize to run some precomputations that will be used throught the simulation and to instantiate containers where the result will be written.","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"containers = initialize(options)","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"And finally, we can start the simulation.","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"@time simulate!(operator=operator, options=options, containers=containers)","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"The simulation is over! Note that the bulk of the time is spent in the precoputation, while the simulation itself is quite fast. This is especially good if we want to test different operation strategies.","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"The result is saved in","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"containers.X","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"This page was generated using Literate.jl.","category":"page"}]
}

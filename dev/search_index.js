var documenterSearchIndex = {"docs":
[{"location":"api/#Public-API","page":"API","title":"Public API","text":"","category":"section"},{"location":"api/#General","page":"API","title":"General","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"These are the functions used to run the simulation. Note that an object of type SimulationOptions is needed to call them.","category":"page"},{"location":"api/","page":"API","title":"API","text":"initialize","category":"page"},{"location":"api/#BoreholeNetworksSimulator.initialize","page":"API","title":"BoreholeNetworksSimulator.initialize","text":"initialize(options::SimulationOptions)\n\nPrecompute the objects of each TimeSuperpositionMethod that can be computed ahead of time and return the SimulationContainers of the required size.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"simulate!","category":"page"},{"location":"api/#BoreholeNetworksSimulator.simulate!","page":"API","title":"BoreholeNetworksSimulator.simulate!","text":"simulate!(;options::SimulationOptions, operator, containers::SimulationContainers)\n\nRun the simulation defined by options.  At the end of simulation, containers.X will contain the results. containers should be the output of initialize.\n\noperator should be a function that returns a BoreholeOperation and with signature operator(i, Tin, Tout, Tb, q, configurations):\n\ni::Int is the time step\nTin is a vector containing the inlet temperature of each borehole\nTout is a vector containing the outlet temperature of each borehole\nTb is a vector containing the borehole wall temperature of each borehole\nq is a vector containing the heat exchanged by each borehole\nconfigurations: is the list of possible hydraulic configurations of the borefield.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Note that an array of BoreholeNetwork containing all the configurations allowed during the simulation must be specified in SimulationOptions. On the other hand, BoreholeOperation is an object that needs to be returns by an operator function at each time step , representing the dynamical changes in the operation. See Basic tutorial for more details.","category":"page"},{"location":"api/","page":"API","title":"API","text":"BoreholeNetwork","category":"page"},{"location":"api/#BoreholeNetworksSimulator.BoreholeNetwork","page":"API","title":"BoreholeNetworksSimulator.BoreholeNetwork","text":"BoreholeNetwork(branches::Vector)\n\nRepresentation of the hydraulic connections of the boreholes in the network. Each element in branches should be a vector representing a branch of boreholes connected in series, specified by their identifiers. The first borehole of each branch is assumed to be connected in parallel. \n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"BoreholeOperation","category":"page"},{"location":"api/#BoreholeNetworksSimulator.BoreholeOperation","page":"API","title":"BoreholeNetworksSimulator.BoreholeOperation","text":"BoreholeOperation{T <: Number}(network::BoreholeNetwork, mass_flows:: Vector{T})\n\nRepresents a operation state of the network, with network representing the hydraulic configuration and mass_flows a Vector containing the mass flow rate of each branch.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation-Options","page":"API","title":"Simulation Options","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The available options for the simulation are specified through a SimulationOptions object. This needs to be passed to the initialize and simulate! functions. The options are modular: each particular option can be chosen independently of the others, allowing for a wide range of possible simulations.  Note that in some particular cases there might be some incompatibilities between options or non-implemented interactions. In those cases, an error will appear explaining the reason.","category":"page"},{"location":"api/","page":"API","title":"API","text":"SimulationOptions","category":"page"},{"location":"api/#BoreholeNetworksSimulator.SimulationOptions","page":"API","title":"BoreholeNetworksSimulator.SimulationOptions","text":"struct SimulationOptions{\n                TSM <: TimeSuperpositionMethod,\n                C <: Constraint,\n                B <: Borefield, \n                M <: Medium, \n                BC <: BoundaryCondition\n            }(\n    method::TSM\n    constraint::C\n    borefield::B\n    medium::M\n    boundary_condition::BoundaryCondition = DirichletBoundaryCondition()\n    fluid::Fluid = Fluid(cpf=4182., name=\"INCOMP::MEA-20%\")\n    configurations::Vector{BoreholeNetwork}\n    Δt\n    Nt::Int\n)\n\nSpecifies all the options for the simulation.\n\nmethod: time superposition method used to compute the response. Available options: ConvolutionMethod, NonHistoryMethod.\nconstraint: constraint that the system must satisfy. Can be variable with time. Available options: HeatLoadConstraint, InletTempConstraint.\nborefield: describes the geometrical properties and the boreholes of the borefield on which the simulation will be performed. Available options: EqualBoreholesBorefield.\nmedium: properties of the ground where the borefield is places. Available options: GroundMedium, FlowInPorousMedium.\nboundary_condition: boundary condition of the domain where the simulation is performed. Available options: NoBoundary, DirichletBoundaryCondition.\nfluid: properties of the fluid flowing through the hydraulic system.\nconfigurations: possible hydraulic topologies possible in the system, including reverse flow.\nΔt: time step used in the simulation.\nNt: total amount of time steps of the simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"The several options are listed below:","category":"page"},{"location":"api/#Medium","page":"API","title":"Medium","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Models the underground medium through which the heat will transfer between boreholes.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Medium","category":"page"},{"location":"api/#BoreholeNetworksSimulator.Medium","page":"API","title":"BoreholeNetworksSimulator.Medium","text":"abstract type Medium\n\nInterface for mediums.\n\nRequired functions:\n\nget_λ(::Medium): Return the thermal conductivity of the medium.\nget_α(::Medium): Return the thermal diffusivity of the medium.\nget_T0(::Medium): Return the initial temperature of the medium.\ncompute_response!(g, ::Medium, borefield::Borefield, boundary_condition::BoundaryCondition, t):    Compute inplace in g the thermal responses between boreholes in borefield,    imposing the boundary condition boundary_condition, for all times in t.\n\n\n\n\n\n","category":"type"},{"location":"api/#Options","page":"API","title":"Options","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"GroundMedium","category":"page"},{"location":"api/#BoreholeNetworksSimulator.GroundMedium","page":"API","title":"BoreholeNetworksSimulator.GroundMedium","text":"GroundMedium{T <: Real} <: Medium @deftype T\n\nModel pure conduction in the ground.\n\nArguments\n\nλ = 3.: ground conductivity\nα = 1e-6: ground thermal diffusivity\nC = λ/α: ground medium capacity\nT0 = 0.: initial ground temperature\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"FlowInPorousMedium","category":"page"},{"location":"api/#BoreholeNetworksSimulator.FlowInPorousMedium","page":"API","title":"BoreholeNetworksSimulator.FlowInPorousMedium","text":"FlowInPorousMedium{T <: Real} <: Medium @deftype T\n\nModel a porous ground with a water flow.\n\nArguments\n\nλw = 0.6: water thermal conductivity\nλs = 2.: ground thermal conductivity\nCw = 4.18*1e6:water thermal capacity\nCs = 1.7*1e6: ground thermal capacity\nθ = 0.: angle of Darcy velocity\nΦ = 0.2: porosity\nλ = λs * (1-Φ) + λw*Φ: porous medium conductivity\nC = Cs * (1-Φ) + Cw*Φ: porous medium capacity\nα = λ/C: porous medium thermal diffusivity\nux_in_meterperday = 1e-2: groundwater speed along the flow coordinate\nux = ux_in_meterperday/(3600*24): groundwater speed in m/s\nvt = ux * Cw/C: porous medium darcy velocity\nT0 = 0.: initial ground temperature\n\n\n\n\n\n","category":"type"},{"location":"api/#Borefield","page":"API","title":"Borefield","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Models the geometry of the borefield.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Borefield","category":"page"},{"location":"api/#BoreholeNetworksSimulator.Borefield","page":"API","title":"BoreholeNetworksSimulator.Borefield","text":"abstract type Borefield\n\nInterface for borefields.\n\nRequired functions\n\nn_boreholes(::Borefield): Return the amount of boreholes present in the borefield.\nget_H(::Borefield, i): Return the length of borehole i.\nget_rb(::Borefield, i): Return the radius of borehole i.\nsegment_coordinates(::Borefield): Return a vector with the coordinates of each segment.  \ninternal_model_coeffs!(M, ::Borefield, medium, operation, fluid): Compute inplace in M   the coefficients corresponding to the internal model equations, given the medium, fluid and   operation in use in the system.   Note that M is only a slice of Nb (number of boreholes) rows, provided as a view.\ninternal_model_b!(b, ::Borefield): Compute inplace in b   the independent terms corresponding to the internal model equations.   Note that b is only a vector of length Nb (number of boreholes) rows, provided as a view.\n\n\n\n\n\n","category":"type"},{"location":"api/#Options-2","page":"API","title":"Options","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"EqualBoreholesBorefield","category":"page"},{"location":"api/#BoreholeNetworksSimulator.EqualBoreholesBorefield","page":"API","title":"BoreholeNetworksSimulator.EqualBoreholesBorefield","text":"EqualBoreholesBorefield{T <: Borehole, R <: Medium, S <: Real} <: Borefield\nEqualBoreholesBorefield(borehole_prototype::T, positions::Vector{Point2{S}}), medium::R)\n\nModel a borefield with boreholes all identical to the prototype borehole_prototype, placed at positions. Note that the length of positions determines the amount of boreholes in the field. medium contains the properties of the ground.\n\n\n\n\n\n","category":"type"},{"location":"api/#Borehole","page":"API","title":"Borehole","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Models the internal heat transfer in the borehole.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Borehole","category":"page"},{"location":"api/#BoreholeNetworksSimulator.Borehole","page":"API","title":"BoreholeNetworksSimulator.Borehole","text":"abstract type Borehole\n\nInterface for boreholes.\n\nRequired functions:\n\nget_H(::Borehole): Return the length of the borehole.\nget_D(::Borehole): Return the burial depth of the borehole.\nget_rb(::Borehole): Return the radius of the borehole.\nuniform_Tb_coeffs(::Borehole, λ, mass_flow, Tref, fluid): Return the internal model coefficients   for the resistance network between the pipes and the wall.\n\n\n\n\n\n","category":"type"},{"location":"api/#Options-3","page":"API","title":"Options","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"SingleUPipeBorehole","category":"page"},{"location":"api/#BoreholeNetworksSimulator.SingleUPipeBorehole","page":"API","title":"BoreholeNetworksSimulator.SingleUPipeBorehole","text":"SingleUPipeBorehole{T <: Real} <: Borehole @deftype T\nSingleUPipeBorehole(H, D)\n\nModel a borehole with a single U-pipe with burial depth D and length H.\n\nArguments\n\nλg = 2.5: grout conductivity\nCg = 2000. * 1550.: grout capacity\nαg = λg/Cg: grout thermal diffusivity\nrp = 0.02: pipe radius\nλp = 0.42: pipe material conductivity\ndpw = 0.0023: pipe thickness\nrpo = rp + dpw: equivalent pipe radius\nhp = 725.: heat transfer coefficient fluid to pipe\npipe_position::NTuple{2, Tuple{T, T}} = [(0.03, 0.0), (-0.03, 0.0)]: positions of the downward and upward branches of the pipe. (0, 0) represents the center of the borehole.\nrb = 0.115/2: borehole radius\n\n\n\n\n\n","category":"type"},{"location":"api/#Constraint","page":"API","title":"Constraint","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Imposes the working conditions and demands of the whole system.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Constraint","category":"page"},{"location":"api/#BoreholeNetworksSimulator.Constraint","page":"API","title":"BoreholeNetworksSimulator.Constraint","text":"abstract type Constraint\n\nInterface for constraints.\n\nRequired functions:\n\nconstraints_coeffs!(M, ::Constraint, operation::BoreholeOperation): Compute inplace in M   the coefficients corresponding to the constraints equations, given the current operation.network.    Note that M is only a slice of Nbr (number of branches) rows, provided as a view.\nconstraints_b!(b, ::Constraint, ::BoreholeOperation, step): Compute inplace in b   the independent term corresponding to the constraints equations, given the current operation.network,   at the time step step.    Note that b is only a vector of length Nbr (number of branches), provided as a view.\n\n\n\n\n\n","category":"type"},{"location":"api/#Options-4","page":"API","title":"Options","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"HeatLoadConstraint","category":"page"},{"location":"api/#BoreholeNetworksSimulator.HeatLoadConstraint","page":"API","title":"BoreholeNetworksSimulator.HeatLoadConstraint","text":"HeatLoadConstraint(Q_tot::Matrix{T}){T <: Number} <: Constraint\n\nConstrain the heat extracted per branch.\n\nThe heat constraint Q_tot must be a Matrix, whose column i are the loads per branch at the  time step i. The amount of rows of Q_tot must equal to the amount of branches specified  in BoreholeNetwork.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"constant_HeatLoadConstraint","category":"page"},{"location":"api/#BoreholeNetworksSimulator.constant_HeatLoadConstraint","page":"API","title":"BoreholeNetworksSimulator.constant_HeatLoadConstraint","text":"constant_HeatLoadConstraint(Q_tot::Vector{T}, Nt) where {T <: Number}\n\nConvenience initializer for HeatLoadConstraint. It creates a constant heat load constraint through all the Nt time steps, where Q_tot are the heat load for each branch.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"uniform_HeatLoadConstraint","category":"page"},{"location":"api/#BoreholeNetworksSimulator.uniform_HeatLoadConstraint","page":"API","title":"BoreholeNetworksSimulator.uniform_HeatLoadConstraint","text":"uniform_HeatLoadConstraint(Q_tot::Vector{T}, Nbr) where {T <: Number}\n\nConvenience initializer for HeatLoadConstraint. It creates a uniform heat load constraint along all branches, where T_in are the heat load for each time step.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"InletTempConstraint","category":"page"},{"location":"api/#BoreholeNetworksSimulator.InletTempConstraint","page":"API","title":"BoreholeNetworksSimulator.InletTempConstraint","text":"InletTempConstraint(T_in::Matrix{T}){T <: Number} <: Constraint\n\nConstrain the inlet temperature of the first borehole in each branch.\n\nThe inlet temperature T_in must be a Matrix, whose column i are the inlet temperatures per branch at the  time step i. The amount of rows of T_in must equal to the amount of branches specified  in BoreholeNetwork.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"constant_InletTempConstraint","category":"page"},{"location":"api/#BoreholeNetworksSimulator.constant_InletTempConstraint","page":"API","title":"BoreholeNetworksSimulator.constant_InletTempConstraint","text":"constant_InletTempConstraint(T_in::Vector{N}, Nt) where {N <: Number}\n\nConvenience initializer for InletTempConstraint. It creates a constant inlet temperature constraint through all the Nt time steps, where T_in are the inlet temperatures for each branch.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"uniform_InletTempConstraint","category":"page"},{"location":"api/#BoreholeNetworksSimulator.uniform_InletTempConstraint","page":"API","title":"BoreholeNetworksSimulator.uniform_InletTempConstraint","text":"uniform_InletTempConstraint(T_in::Vector{N}, Nbr) where {N <: Number}\n\nConvenience initializer for InletTempConstraint. It creates a uniform inlet temperature constraint along all branches, where T_in are the inlet temperatures for each time step.\n\n\n\n\n\n","category":"function"},{"location":"api/#Time-Superposition-Method","page":"API","title":"Time Superposition Method","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Applies methods for time superposition.","category":"page"},{"location":"api/","page":"API","title":"API","text":"TimeSuperpositionMethod","category":"page"},{"location":"api/#BoreholeNetworksSimulator.TimeSuperpositionMethod","page":"API","title":"BoreholeNetworksSimulator.TimeSuperpositionMethod","text":"abstract type TimeSuperpositionMethod\n\nInterface for time superposition methods.\n\nRequired functions:\n\nmethod_coeffs!(M, ::TimeSuperpositionMethod, borefield, medium, boundary_condition): Compute inplace in M   the coefficients corresponding to the heat transfer equations, given the medium,    and boundary_condition in use in the system.   Note that M is only a slice of Nbr (number of branches) rows, provided as a view.\nmethod_b!(b, ::TimeSuperpositionMethod, borefield, medium, step): Compute inplace in b   the independent terms corresponding to the heat transfer equations, given the medium,    at the given time step step.   Note that b is only a vector of length Nbr (number of branches) rows, provided as a view.\nprecompute_auxiliaries!(method::TimeSuperpositionMethod; options): Compute inplace in method    the auxiliary quantities used in the simulation that can be performed ahead of time.\nupdate_auxiliaries!(::TimeSuperpositionMethod, X, borefield, step): Update inplace in method   the auxiliaries after each time step step.\n\n\n\n\n\n","category":"type"},{"location":"api/#Options-5","page":"API","title":"Options","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ConvolutionMethod","category":"page"},{"location":"api/#BoreholeNetworksSimulator.ConvolutionMethod","page":"API","title":"BoreholeNetworksSimulator.ConvolutionMethod","text":"ConvolutionMethod{T} <: TimeSuperpositionMethod \nConvolutionMethod()\n\nUse the naïve convolution to compute the thermal response between boreholes.  It should be initialized without arguments, but it contains the variables:\n\ng stores the unit response between each pair of boreholes evaluated at each time of the simulation. \n\nIt should be precomputed with initialize.\n\nq stores the heat extraction in each borehole at each time step. It is filled as the simulation runs. \n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"NonHistoryMethod","category":"page"},{"location":"api/#BoreholeNetworksSimulator.NonHistoryMethod","page":"API","title":"BoreholeNetworksSimulator.NonHistoryMethod","text":"NonHistoryMethod{T} <: TimeSuperpositionMethod \nNonHistoryMethod()\n\nUse the non-history method to compute the thermal response between boreholes.  See A non-history dependent temporal superposition algorithm for the finite line source solution. It should be initialized without arguments, but it contains the variables:\n\nF::Matrix{T}: each column contains the F function (encoding the load history) for each borehole. It is initially 0.\nζ::Vector{T}: discretization nodes of the integration interval. Shared for all boreholes. Precomputed in initialize.\nw::Matrix{T}: weights of the ζ integration for each pair of boreholes. Precomputed in initialize.\nexpΔt::Vector{T}: exp(-ζ^2*Δt). Precomputed in initialize.\n\nThis feature is experimental and might not work as expected in some cases. \n\n\n\n\n\n","category":"type"},{"location":"api/#Boundary-Condition","page":"API","title":"Boundary Condition","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Models the ground surface.","category":"page"},{"location":"api/","page":"API","title":"API","text":"BoundaryCondition","category":"page"},{"location":"api/#BoreholeNetworksSimulator.BoundaryCondition","page":"API","title":"BoreholeNetworksSimulator.BoundaryCondition","text":"abstract type BoundaryCondition\n\nInterface for boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"api/#Options-6","page":"API","title":"Options","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"NoBoundary","category":"page"},{"location":"api/#BoreholeNetworksSimulator.NoBoundary","page":"API","title":"BoreholeNetworksSimulator.NoBoundary","text":"NoBoundary <: BoundaryCondition\n\nOption to solve the problem in an infinite domain \n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"DirichletBoundaryCondition","category":"page"},{"location":"api/#BoreholeNetworksSimulator.DirichletBoundaryCondition","page":"API","title":"BoreholeNetworksSimulator.DirichletBoundaryCondition","text":"DirichletBoundaryCondition <: BoundaryCondition\n\nOption to enforce that the surface plane z=0 remains at temperature T=0\n\n\n\n\n\n","category":"type"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"EditURL = \"nonhistory.jl\"","category":"page"},{"location":"nonhistory/#Non-history-method","page":"Non-history method","title":"Non-history method","text":"","category":"section"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"The non-history method is a time superposition method introduced in [1] whose computational complexity in the number of time steps N_t is mathcalOleft( N_t right). Recall that the standard way to do time superposition is via the convolution of the load with the response, which implemented via the Fast Fourier Transform, yields a computational complexity of mathcalOleft( N_t logN_t right). This means that using the non-history method in simulations allows for finer time steps.","category":"page"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"To show this, let us run a simulation with hourly time steps, with a duration of 1 year (so 8760 time steps), with both the convolution and the non-history time superposition methods. Let us define an example, very similar to Basic tutorial","category":"page"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"using BoreholeNetworksSimulator","category":"page"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"Δt = 3600.#8760*3600/12.\nNt = 8760\n\nmedium = GroundMedium(α=1e-6, λ=3., T0=10.)\nborehole = SingleUPipeBorehole(H=10., D=10.)\npositions = [(0., 0.), (0., 5.)]\nborefield = EqualBoreholesBorefield(borehole_prototype=borehole, positions=positions)\nconstraint = constant_HeatLoadConstraint(5 .* ones(BoreholeNetworksSimulator.n_boreholes(borefield)), Nt)\n\nconfigurations = [BoreholeNetwork([[1], [2]])]\n\nfunction operator(i, Tin, Tout, Tb, q, configurations)\n    network = configurations[1]\n    BoreholeOperation(network, 2 .* ones(n_branches(network)))\nend","category":"page"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"Now, we define two different options using different method parameters, one with ConvolutionMethod corresponding to the convolution, and the other with NonHistoryMethod, corresponding with the non-history method.","category":"page"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"options_convolution = SimulationOptions(\n    method = ConvolutionMethod(),\n    constraint = constraint,\n    borefield = borefield,\n    medium = medium,\n    Δt = Δt,\n    Nt = Nt,\n    configurations = configurations\n)\n\noptions_nonhistory = SimulationOptions(\n    method = NonHistoryMethod(),\n    constraint = constraint,\n    borefield = borefield,\n    medium = medium,\n    Δt = Δt,\n    Nt = Nt,\n    configurations = configurations\n)","category":"page"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"Let us run the convolution","category":"page"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"containers_convolution = @time initialize(options_convolution)\n@time simulate!(operator=operator, options=options_convolution, containers=containers_convolution)","category":"page"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"And now let us run the non-history","category":"page"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"containers_nonhistory = @time initialize(options_nonhistory)\n@time simulate!(operator=operator, options=options_nonhistory, containers=containers_nonhistory)\n\n\nabs.(containers_convolution.X - containers_nonhistory.X)","category":"page"},{"location":"nonhistory/#References","page":"Non-history method","title":"References","text":"","category":"section"},{"location":"nonhistory/","page":"Non-history method","title":"Non-history method","text":"[1] Lazzarotto, Alberto; Basquens, Marc; Cimmino, Massimo; Non-history dependent temporal superposition algorithm for the pint source solution, Research Conference Proceedings of the IGSHPA (2024).","category":"page"},{"location":"python/#Running-BoreholeNetworksSimulator-from-Python","page":"Running from python","title":"Running BoreholeNetworksSimulator from Python","text":"","category":"section"},{"location":"python/","page":"Running from python","title":"Running from python","text":"It is also possible to run BoreholeNetworksSimulator from Python by using its Julia interoperability (achieved with the package PythonCall.jl and the module juliacall) while keeping roughly the same syntax. For a more detailed explanation of how this works, please visit the PythonCall.jl documentation. This requires to have installed in your python environment the modules juliacall and numpy.","category":"page"},{"location":"python/","page":"Running from python","title":"Running from python","text":"BoreholeNetworksSimulator.jl contains a second Julia module called BNSPythonAdapter whose purpose is to make the necessary conversions between Python and Julia. This module is not intended to be used from Julia, but from within Python. In this tutorial, we will repeat the example in Basic tutorial but run from Python to show how it works. The full example as a Python script in at BNSPythonAdapter/example.py.","category":"page"},{"location":"python/","page":"Running from python","title":"Running from python","text":"BNSPythonAdapter contains a python script src/adapter.py that executes the necessary bridging code. You should start your python program by importing this module. Assuming that the package directory is added to the sys.path, this should work:","category":"page"},{"location":"python/","page":"Running from python","title":"Running from python","text":"import src.adapter","category":"page"},{"location":"python/","page":"Running from python","title":"Running from python","text":"The script takes care of activating the Julia package BNSPythonAdapter which has BoreholeNetworksSimulator as a dependency, and loads both namespaces for later use. It also defines conversions from Python objects to their Julia counterparts.  Next, we need to import juliacall to be able to reference objects and funcions from BoreholeNetworksSimulator. It is useful to give it an alias for conciseness.","category":"page"},{"location":"python/","page":"Running from python","title":"Running from python","text":"from juliacall import Main as jl","category":"page"},{"location":"python/","page":"Running from python","title":"Running from python","text":"Now, the python variable jl represents the Main module in Julia, and it has as methods all the Julia functions available in it. Since we imported the namespace BoreholeNetworksSimulator, this also includes its objects and functions.","category":"page"},{"location":"python/","page":"Running from python","title":"Running from python","text":"Then, we define the same variables as in Basic tutorial:","category":"page"},{"location":"python/","page":"Running from python","title":"Running from python","text":"Δt = 8760*3600/12.\nNt = 10*12\n\nα = 1e-6\nλ = 3.\nT0 = 10.\nmedium = jl.GroundMedium(α=α, λ=λ, T0=T0)\n\nD = 10.\nH = 100.\n\nborehole = jl.SingleUPipeBorehole(H=H, D=D)\n\nσ = 5.\npositions = jl.Array[jl.Tuple[jl.Float64, jl.Float64]]([(0., 0.), (0., σ)])\nborefield = jl.EqualBoreholesBorefield(borehole_prototype=borehole, positions=positions)\n\nconfigurations = [jl.BoreholeNetwork([[1], [2]])]\n\nq1 = 5.\nq2 = 5.\nloads = jl.Array[jl.Float64]([q1, q2])\nconstraint = jl.constant_HeatLoadConstraint(loads, Nt)\n\noptions = jl.SimulationOptions(\n    method = jl.ConvolutionMethod(),\n    constraint = constraint,\n    borefield = borefield,\n    medium = medium,\n    Δt = Δt,\n    Nt = Nt,\n    configurations = configurations\n)","category":"page"},{"location":"python/","page":"Running from python","title":"Running from python","text":"Note that the code itself is not very different from its Julia version, but there are two remarks worth making. First, we need to call any object defined in Julia by typing jl. in front. This creates a python object with the same fields that PythonCall.jl knows how to convert back into a Julia object. Second, note that we have defined the arrays by explicitly declaring their generic type. If we don't do this, they will be converted into Vector{Any} in the Julia code, which is not desirable.","category":"page"},{"location":"python/","page":"Running from python","title":"Running from python","text":"Another difference is the definition of our operator object. Since we are writing python, it should now be a python function, however, since the Julia code is expecting an object of type BoreholeOperation, its return type must be jl.BoreholeOperation, that PythonCall.jl knows how to convert. ","category":"page"},{"location":"python/","page":"Running from python","title":"Running from python","text":"def operator(i, Tin, Tout, Tb, q, configurations):\n    return jl.BoreholeOperation(configurations[0], jl.Array[jl.Float64]([2., 2.]))","category":"page"},{"location":"python/","page":"Running from python","title":"Running from python","text":"Finally we can run the simulation","category":"page"},{"location":"python/","page":"Running from python","title":"Running from python","text":"containers = jl.initialize(options)\njl.simulate_b(operator=operator, options=options, containers=containers)","category":"page"},{"location":"python/","page":"Running from python","title":"Running from python","text":"Note that the bang in simulate! is replaced by a _b in the juliacall version of the function. ","category":"page"},{"location":"python/","page":"Running from python","title":"Running from python","text":"containers.X","category":"page"},{"location":"python/","page":"Running from python","title":"Running from python","text":"Now, one can compare this result with its Julia version. If everything went right, they should agree!","category":"page"},{"location":"#BoreholeNetworksSimulator.jl","page":"Introduction","title":"BoreholeNetworksSimulator.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"BoreholeNetworksSimulator.jl is a pure Julia, performant, and modular framework for simulations of fields of interconnected borehole heat exchangers. Features:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Computes fluid temperatures, borehole wall temperatures and heat extracted. \nSupports many different configurations and settings by being highly modular: boreholes, hydraulic configurations, ground properties, load demand or temperature  constraints, ground boundary conditions can be seamlessly used with minimal effort. \nAllows for design of operation strategies via an operator callback at each time step.\nImplements the \"non-history\" time superposition method, reducing the computational complexity in the number of time steps to linear. This allows for simulations with fine time steps.\nPython interoperability.","category":"page"},{"location":"#Getting-started","page":"Introduction","title":"Getting started","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"BoreholeNetworksSimulator.jl is currently not in Julia's General registry (as well as some of its dependencies), however, it is easily available through the local registry geothermal_registry.  In order to install it, start Julia and run the command:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg; pkg\"registry add https://github.com/marcbasquensmunoz/geothermal_registry\"; Pkg.add(\"BoreholeNetworksSimulator\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In order to learn how to use this package, please visit Basic tutorial first.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For users interested in running BoreholeNetworksSimulator.jl from Python, see also Running BoreholeNetworksSimulator from Python.","category":"page"},{"location":"#Design-philosophy","page":"Introduction","title":"Design philosophy","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The driving motivation when developing BoreholeNetworksSimulator.jl was to create an easy to use tool that is also highly flexible and performant.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This goal has been accomplished by leveraging Julia's Multiple Dispatch. Through a simple, common interface, the user can run a plethora of different simulations by modularly specifying options. Some options have physical meaning or interpretation, while others are purely algorithmic, yet they can all be seamlessly changed by changing a parameter. Please, refer to Public API for the full list of options offered by this package.","category":"page"},{"location":"Braedsturp/#Example","page":"Braedsturp","title":"Example","text":"","category":"section"},{"location":"Braedsturp/","page":"Braedsturp","title":"Braedsturp","text":"The example considers a borehole field of 48 boreholes connected according to scheme utilized in the installation in Braedsturp, Denmark. ","category":"page"},{"location":"Braedsturp/","page":"Braedsturp","title":"Braedsturp","text":"<img src=\"examples/old/results/configuration.png\" width=\"400\" height=\"400\" />","category":"page"},{"location":"Braedsturp/#Run-the-example","page":"Braedsturp","title":"Run the example","text":"","category":"section"},{"location":"Braedsturp/","page":"Braedsturp","title":"Braedsturp","text":"include(\"examples/modular/main.jl\")","category":"page"},{"location":"Braedsturp/","page":"Braedsturp","title":"Braedsturp","text":"In this example, the simulation is executed and the results are saved in the cache file named 'cache_3.1536e8.jld2'. The result data is also available in memory:","category":"page"},{"location":"Braedsturp/","page":"Braedsturp","title":"Braedsturp","text":"julia> containers.X\n192×120 Matrix{Float64}:\n  70.8847   75.0666   77.993    79.8948   81.1608  …  55.0      55.0      55.0      55.0\n  67.5464   71.9367   75.0863   77.1524   78.5424     54.0451   53.9479   53.8829   53.8375\n  74.3405   78.1643   80.7556   82.4294   83.5353     54.0451   53.9479   53.8829   53.8375\n  70.8847   75.0666   77.993    79.8948   81.1608     53.3751   53.162    53.0222   52.9267\n  78.015    81.4475   83.6781   85.1081   86.0436     53.3751   53.162    53.0222   52.9267\n   ⋮                                               ⋱                                \n 166.095   -45.855   -26.2117  -19.1312  -14.2904      8.85064   6.64457   5.00616   3.79414\n 176.965   -50.0092  -28.9111  -21.2066  -15.7431      8.59637   6.57639   4.9994    3.79898\n 187.948   -55.3887  -30.2105  -21.656   -15.8568  …   7.91946   6.12587   4.71477   3.6243\n 179.911   -47.192   -24.6851  -18.3117  -13.8542      6.52704   5.39342   4.38165   3.54095","category":"page"},{"location":"Braedsturp/#Plots","page":"Braedsturp","title":"Plots","text":"","category":"section"},{"location":"Braedsturp/","page":"Braedsturp","title":"Braedsturp","text":"Plots showing the results of the simulation as also available","category":"page"},{"location":"Braedsturp/","page":"Braedsturp","title":"Braedsturp","text":"julia > include(\"examples/plots/sim1.jl\") ","category":"page"},{"location":"Braedsturp/","page":"Braedsturp","title":"Braedsturp","text":"Inlet borehole temperatures and heat flows for boreholes along two branches in the borehole field. The time series are color coded according to the previous configuration plot above. In addition to the inlet temperature, the output temperature from the branch (grey dot), and the mean output temperature from the field (black dot) are displayed.","category":"page"},{"location":"Braedsturp/","page":"Braedsturp","title":"Braedsturp","text":"<img src=\"examples/old/results/sym1/branch1test1.png\" width=\"600\" height=\"300\" /> <img src=\"examples/old/results/sym1/branch2test1.png\" width=\"600\" height=\"300\" />","category":"page"},{"location":"Braedsturp/","page":"Braedsturp","title":"Braedsturp","text":"Finally we can display the heatmap of the temperature field in the borehole region during the 10th year of operation","category":"page"},{"location":"Braedsturp/","page":"Braedsturp","title":"Braedsturp","text":"<img src=\"examples/old/results/sym1/heatmap_test1.png\" width=\"600\" height=\"300\" />","category":"page"},{"location":"Braedsturp/#Running-the-code-in-Python","page":"Braedsturp","title":"Running the code in Python","text":"","category":"section"},{"location":"Braedsturp/","page":"Braedsturp","title":"Braedsturp","text":"Julia is interoperable with Python, making it possible to run this code from Python. In order to so do, install the Python module juliacall and run ","category":"page"},{"location":"Braedsturp/","page":"Braedsturp","title":"Braedsturp","text":"python3 examples/modular/main.py","category":"page"},{"location":"Braedsturp/","page":"Braedsturp","title":"Braedsturp","text":"This script calls the same code as the main.jl.","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"EditURL = \"tutorial.jl\"","category":"page"},{"location":"tutorial/#Basic-tutorial","page":"Basic tutorial","title":"Basic tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"In this tutorial we will learn how to simulate the expected temperature and heat extraction in a borehole field.","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"First, we need to specify the parameters and constraints of our system, as well as some options for the simulation. This is done through a SimulationOptions object. Its variables are modular components with which we can describe many scenarios by leveraging Julia's multiple dispatch. Let us see the components one by one with an example.","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"We start by specifying the simulation time step and the simulation duration. For our example, we will take monthly time steps during 10 years:","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"using BoreholeNetworksSimulator","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"Δt = 8760*3600/12.\nNt = 10*12","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"Suppose the ground we are interested in simulating is made of solid rock. This means the heat transfer will occur by pure conduction. Assume that the thermal diffusivity of the rock is α = 10^-6 fracm^2s and its thermal conductivity is λ = 3 fracWm  K. The undisturbed temperature of the ground is T_0=10  ^circC. We model the ground with a subtype of Medium, in our case, as per our assumptions, we are particularly interested in GroundMedium:","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"α = 1e-6\nλ = 3.\nT0 = 10.\nmedium = GroundMedium(α=α, λ=λ, T0=T0)\n\n\nD = 10.\nH = 100.\nborehole = SingleUPipeBorehole(H=H, D=D)","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"Next, we need to know how and where the boreholes in our system are. Suppose we are interested in simulating the evolution of two identical vertical boreholes of length H=100m and buried at depth D=10m, separated by a distance of σ=5m. The boreholes are of the U-type. We need to enconde this information in a subtype of Borefield. Since the boreholes in our example have the same properties, we can use EqualBoreholesBorefield, which instantiates several identical boreholes from a prototype. The prototype is specified by a subtype of Borehole. In our case, we can use SingleUPipeBorehole to model a borehole with a single U-pipe.","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"D = 10.\nH = 100.\n\nborehole = SingleUPipeBorehole(H=H, D=D)","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"There are more parameters that are also relevant, such as borehole radius, grout properties, pipe resistance, etc., but for the moment we will use their default values.","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"Next, we need to specify where the borehole are located.","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"σ = 5.\npositions = [(0., 0.), (0., σ)]\nborefield = EqualBoreholesBorefield(borehole_prototype=borehole, positions=positions)","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"Note that we didn't specify yet how the boreholes are connected. This is because the simulation allows for dynamical changes in the network hydraulic configuration. Using different configurations, we can simulate the reverse flow, or even simulate valves opening and closing. The reason behind this design is to allow for decision making on the operation of the borefield during the simulation, based on the inputs that we are interested in.","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"For now, let us state the possible hydraulic configurations that we will allows our borefield to be in. This is done with an vector of BoreholeNetwork. Borefields usually have several branches of boreholes. Each borehole in a branch is connected in series, while branches may o may not be connected in parallel between themselves. To create a BoreholeNetwork, we need to provide all of its branches in a vector. Each branch is, in turn, a vector containing the identifiers, in order, of the boreholes present in that branch. Each identifier i::Int refers to the borehole located at position positions[i].","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"In our example, we want to simulate two independent boreholes, so each of them must be in a separate branch. Also, for the moment, we are only interested in this configuration, so we define:","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"configurations = [BoreholeNetwork([[1], [2]])]","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"Even with all these specifications, the evolution of the system is still not fully determined. The missing conditions are referred to as constraints, and are modeled by subtypes of Constraint. For instance, if we would like the two boreholes to be connected in parallel, we would still need to impose that their inlet temperatures be equal. In our example, since we want out boreholes to be independent, we will impose the total amount of heat that we want to extract from each borehole. We will impose a constant load, equal for both boreholes. This is specified by","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"q1 = 5.\nq2 = 5.\nconstraint = constant_HeatLoadConstraint([q1, q2], Nt)","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"We can finally create the object with all the options:","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"options = SimulationOptions(\n    method = ConvolutionMethod(),\n    constraint = constraint,\n    borefield = borefield,\n    medium = medium,\n    Δt = Δt,\n    Nt = Nt,\n    configurations = configurations\n)","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"As we have mentioned, the simulation is designed to allow for a controllable opeartion during its duration. We do this by defining a function that takes as an input the current state of the borefield and outputs a BoreholeOperation object. This object has two variables: the first specifies which configuration will be used for the next time step. In our case, we only want a single configuration. The second specifies the mass flow rate through each branch of the selected configuration, provided as a vector. In our example, we will keep this constant through the simulation:","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"function operator(i, Tin, Tout, Tb, q, configurations)\n    network = configurations[1]\n    BoreholeOperation(network, 2 .* ones(n_branches(network)))\nend","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"Before simulating, we first need to call initialize to run some precomputations that will be used throught the simulation and to instantiate containers where the result will be written.","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"containers = initialize(options)","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"And finally, we can start the simulation.","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"@time simulate!(operator=operator, options=options, containers=containers)","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"The simulation is over! Note that the bulk of the time is spent in the precoputation, while the simulation itself is quite fast. This is especially good if we want to test different operation strategies.","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"The result is saved in","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"containers.X","category":"page"},{"location":"tutorial/","page":"Basic tutorial","title":"Basic tutorial","text":"Each column in containers.X contains the results for a time step. In each column, the first 2 N_b correspond to the fluid temperatures. In particular,   the odd entries containers.X[1:2:2Nb, :] are the inlet temperatures, while the even entries containers.X[2:2:2Nb, :] are the outlet temperatures of each borehole. The next N_b values containers.X[2Nb+1:3Nb, :] are the borehole wall temperatures. The last N_b values containers.X[3Nb+1:4Nb, :] are the heat extraction of each borehole.","category":"page"}]
}
